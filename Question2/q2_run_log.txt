> ###############################################################################
> # Question 2: ADaM ADSL Dataset Creation (using {admiral})
> # Program: question_2_adam_create_ads1.R 
> # Purpose: Create an ADSL (Subject Level) dataset using SDTM source data, 
> #          the {admiral} family of packages, and tidyverse tools
> # Inputs: pharmaversesdtm::dm, pharmaversesdtm::vs, pharmaversesdtm::ex, 
> #         pharmaversesdtm::ds, pharmaversesdtm::ae
> # Output: ADSL with AGEGR9/AGEGR9N, TRTSDTM/TRTSTMF, ITTFL, LSTAVLDT
> ###############################################################################
> 
> # Loading in Libraries
> library(tidyverse)
> library(pharmaversesdtm)
> library(admiral)
> library(stringr)
> 
> # ------------Reading in the data ---------------------------------------
> dm <- pharmaversesdtm::dm
> vs <- pharmaversesdtm::vs
> ex <- pharmaversesdtm::ex
> ds <- pharmaversesdtm::ds
> ae <- pharmaversesdtm::ae
> 
> # Convering blanks in data to NA
> dm <- convert_blanks_to_na(dm)
> vs <- convert_blanks_to_na(vs)
> ex <- convert_blanks_to_na(ex)
> ds <- convert_blanks_to_na(ds)
> ae <- convert_blanks_to_na(ae)
> 
> 
> # ------------Setting up ADSL ---------------------------------------
> adsl <- dm %>%
+   select(-DOMAIN)
> 
> # ------------Derive AGEGR9 / AGEGR9N ---------------------------------------
> # AGEGR9: Categorical age group from DM.AGE: "<18", "18 - 50", ">50"
> # AGEGR9N: Numeric version of AGEGR9 with categories coded as 1, 2, 3
> adsl <- adsl %>% 
+   mutate(
+     # Text version of Age groups
+     AGEGR9 = case_when(
+       AGE < 18 ~ "<18", 
+       AGE >= 18 & AGE <= 50 ~ "18-50", 
+       AGE > 50 ~ ">50", 
+       TRUE ~ NA_character_
+     ), 
+     # Numeric version of Age groups, numbered 1,2, and 3
+     AGEGR9N = case_when(
+       AGE < 18 ~ 1L, 
+       AGE >= 18 & AGE <= 50 ~ 2L, 
+       AGE > 50 ~ 3L, 
+       TRUE ~ NA_integer_
+     )
+   )
> 
> # ------------Derive TRTSDTM / TRTSTMF ---------------------------------------
> # TRTSDTM: Datetime of subject's FIRST valid exposure start (from EX.EXSTDTC),
> #          sorted by EXSTDTM and EXSEQ.
> #          Include only EX records with:
> #            - valid dose: EXDOSE > 0 OR (EXDOSE == 0 AND EXTRT contains "PLACEBO")
> #            - complete date part of EXSTDTC (i.e., EXSTDTM is not missing)
> #
> # Time imputation rules (applied in derive_vars_dtm):
> #   - If time is completely missing -> impute 00:00:00
> #   - If time is partially missing  -> impute missing HH/MM/SS components with "00"
> #   - If ONLY seconds are missing   -> impute seconds to "00" BUT DO NOT set TRTSTMF
> #
> # TRTSTMF: Imputation flag for TRTSDTM
> #   - "Y" if hours or minutes were imputed
> #   - NA otherwise (including "seconds-only" imputation; ignore_seconds_flag = TRUE)
> 
> # Derive date time object for treatment start date
> ex_ext <-  ex %>% 
+   derive_vars_dtm(
+     dtc = EXSTDTC, # input
+     new_vars_prefix = "EXST", # output
+     time_imputation = "first", # impute missing time to 00:00:00 (first time of day), 
+     flag_imputation = "time", # flag if time is imputed
+     ignore_seconds_flag = TRUE # if only seconds msising do not flag
+     ) 
> 
> # Create a "valid dose" subset of EX:
> #     - Valid dose = EXDOSE > 0 OR (EXDOSE == 0 AND EXTRT contains "PLACEBO")
> #     - Also require EXSTDTM not missing (means date part of EXSTDTC was complete enough)
> 
> ex_for_trt <- ex_ext %>%
+   mutate(
+     valid_dose =
+       (EXDOSE > 0) |
+       (EXDOSE == 0 & !is.na(EXTRT) & str_detect(toupper(EXTRT), "PLACEBO")),
+     
+     # TRTSTMF is a Y/NA flag:
+     # - "Y" if hours or minutes were imputed
+     # - NA otherwise (including "seconds-only" imputation)
+     TRTSTMF_TMP = case_when(
+       EXSTTMF %in% c("H", "M") ~ "Y",
+       TRUE ~ NA_character_
+     )
+   ) %>%
+   filter(valid_dose, !is.na(EXSTDTM))
> 
> # Merge FIRST valid exposure record into ADSL: 
> #     - order by earliest EXSTDTM (with EXSEQ as a tie breaker if needed)
> #     - mode = "first" --> picks the first record per subject
> #     - officially create TRTSDTM and TRTSTMF in ADSL
> adsl <- adsl %>% 
+   derive_vars_merged(
+     dataset_add = ex_for_trt, # external data 
+     new_vars = exprs(TRTSDTM = EXSTDTM, # mapping to new vars
+                      TRTSTMF = TRTSTMF_TMP), 
+     by_vars = exprs(STUDYID,   # grouping vars
+                     USUBJID),
+     mode = "first", # first obs
+     order = exprs(EXSTDTM, EXSEQ) # sort order
+   )
> 
> # ------------Derive ITTFL ---------------------------------------------------
> # ITTFL: Intent-to-treat flag (randomized population)
> # Set to "Y" if ARM is populated (not missing), else "N"
> 
> adsl <- adsl %>% 
+   mutate(ITTFL = ifelse(!is.na(ARM), "Y", "N"))
> 
> # ------------Derive TRTEDTM (supporting variable for LSTAVLDT) --------------
> # TRTEDTM: Datetime of subject's LAST valid exposure record (based on EX.EXSTDTC),
> #          using the same valid dose definition as TRTSDTM.
> #          Time is imputed to end-of-day ("last") when missing.
> # Note: LSTAVLDT uses the DATEPART of TRTEDTM as one source of "last known alive" evidence.
> 
> ex_end <- ex %>%
+   derive_vars_dtm(
+     dtc = EXSTDTC,
+     new_vars_prefix = "EXEN",
+     time_imputation = "last",
+     flag_imputation = "time"
+   )
> 
> adsl <- adsl %>%
+   derive_vars_merged(
+     dataset_add = ex_end,
+     by_vars = exprs(STUDYID, USUBJID),
+     filter_add =
+       (EXDOSE > 0 | (EXDOSE == 0 & str_detect(toupper(EXTRT), "PLACEBO"))) &
+       !is.na(EXENDTM),
+     order = exprs(EXENDTM, EXSEQ),
+     mode = "last",
+     new_vars = exprs(TRTEDTM = EXENDTM)
+   )
> 
> # ------------Derive LSTAVLDT ------------------------------------------------
> # LSTAVLDT: Last known alive date = maximum of the following dates (per subject):
> #   VS: last complete vital signs date (VS.VSDTC) where a result exists
> #       (VS.VSSTRESN and VS.VSSTRESC not both missing)
> #   AE: last complete adverse event onset date (AE.AESTDTC)
> #   DS: last complete disposition date (DS.DSSTDTC)
> #   Treatment: datepart of TRTEDTM (last valid exposure datetime)
> 
> 
> # Define helper for complete datepart meaning the string starts with YYYY-MM-DD
> is_complete_datepart <- function(x) {
+   !is.na(x) & str_detect(x, "^\\d{4}-\\d{2}-\\d{2}")
+ }
> 
> # Take the last date accross multiple datasets:
> # Defines a list of events; each even provides a possible date, then take the last one per subject
> adsl <- adsl %>%
+   # stacks events from multiple places then selects last event per subject
+   derive_vars_extreme_event(
+     by_vars = exprs(STUDYID, USUBJID),
+     
+     events = list(
+       # VS last complete date with valid result
+       event(
+         dataset_name = "vs",
+         order = exprs(VSDTC),
+         
+         # only VS rows with a real assessment and complete date count as being alive
+         condition = is_complete_datepart(VSDTC) &  # datepart msut be compelted 
+           !(is.na(VSSTRESN) & is.na(VSSTRESC)),   # vital signs must have a result
+         
+         # defines what value this event contributes
+         set_values_to = exprs(
+           LSTAVLDT = convert_dtc_to_dt(VSDTC),  # converts character date to real date
+           seq = coalesce(VSSEQ, 0L) # if 2 vs records share same date --> use VSSEQ otherwise if missing --> 0
+         )
+       ),
+       
+       # AE last complete onset date
+       event(
+         dataset_name = "ae",
+         order = exprs(AESTDTC, AESEQ),
+         condition = is_complete_datepart(AESTDTC), # only use complete datepart
+         set_values_to = exprs(
+           LSTAVLDT = convert_dtc_to_dt(AESTDTC),
+           seq = AESEQ
+         )
+       ),
+       
+       # DS last complete disposition date
+       event(
+         dataset_name = "ds",
+         order = exprs(DSSTDTC, DSSEQ),
+         condition = is_complete_datepart(DSSTDTC),
+         set_values_to = exprs(
+           LSTAVLDT = convert_dtc_to_dt(DSSTDTC),
+           seq = DSSEQ
+         )
+       ),
+       
+       # Treatment last administration date from ADSL.TRTEDTM (datepart)
+       # treatment date already in adsl --> no order needed
+       event(
+         dataset_name = "adsl", 
+         condition = !is.na(TRTEDTM),
+         set_values_to = exprs(
+           LSTAVLDT = as.Date(TRTEDTM),
+           seq = 0L
+         )
+       )
+     ),
+     # tells package which dataset to use 
+     source_datasets = list(vs = vs, ae = ae, ds = ds, adsl = adsl),
+     
+     # temporary event number variable
+     tmp_event_nr_var = event_nr,
+     
+     # choose the latest across all candidate LSTAVLDT values
+     order = exprs(LSTAVLDT, seq, event_nr),
+     mode = "last",
+     
+     # add LSTAVLDT to adsl dataset
+     new_vars = exprs(LSTAVLDT)
+   )
> 
> # ------------Formatting final ADAM ADSL dataset ---------------------------------------
> adsl_final <- adsl %>% 
+   select(
+     STUDYID, SUBJID, AGEGR9, AGEGR9N, TRTSDTM, 
+          TRTSTMF, ITTFL, TRTEDTM, LSTAVLDT
+     )
> 
> # ------------Saving ADAM ADSL dataset ------------------------------------------------
> # Derived variables are at the end of dataset
> write.csv(adsl_final, "Question2/adam_adsl.csv", row.names = FALSE) 


Runs successful with no errors!! :D 